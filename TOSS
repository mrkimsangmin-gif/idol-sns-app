한국의 '토스(Toss)' 서비스가 사용자에게 극도로 빠른 속도감을 주는 비결은 **'물리적인 로딩 속도 단축(Engineering)'**과 **'사용자가 느끼는 대기 시간 제거(UX Psychology)'**라는 두 가지 축을 극한으로 최적화했기 때문입니다.

토스팀이 기술 블로그(Toss Feed)와 컨퍼런스(Slash) 등을 통해 공유한 내용을 바탕으로, 웹페이지나 웹앱 개발 시 바로 적용할 수 있는 핵심 전략을 정리해 드립니다.

---

### 1. 렌더링 전략: "기다림 없는 첫 화면"

토스는 초기 진입 속도를 높이기 위해 서버 사이드 렌더링(SSR)과 정적 사이트 생성(SSG)을 적극적으로 활용합니다.

*   **Next.js 기반의 SSR/SSG 도입:**
    *   **원리:** 브라우저가 자바스크립트를 다운로드하고 실행해서 화면을 그리는(CSR) 방식은 초기 로딩이 느립니다. 대신 서버에서 미리 완성된 HTML을 만들어 보내주면(SSR) 사용자는 진입과 동시에 콘텐츠를 볼 수 있습니다.
    *   **적용:** React를 사용한다면 **Next.js** 프레임워크를 도입하여 초기 로딩 속도(LCP)를 획기적으로 줄이세요.
*   **Code Splitting (코드 분할):**
    *   **원리:** 전체 코드를 한 번에 불러오는 대신, 현재 페이지에 필요한 코드만 조각(Chunk)내어 불러옵니다.
    *   **적용:** `React.lazy`나 Next.js의 `dynamic import`를 사용하여 당장 필요 없는 무거운 컴포넌트나 라이브러리는 나중에 로딩되도록 처리합니다.

### 2. 체감 속도 향상 (Perceived Performance): "반응은 즉시"

네트워크 속도가 느려도 사용자는 앱이 빠르다고 느끼게 만드는, 토스 경험의 핵심입니다.

*   **낙관적 UI (Optimistic UI):**
    *   **핵심:** 서버의 응답을 기다리지 않고 **"이미 성공했다"고 가정하고 화면을 먼저 바꿉니다.**
    *   **예시:** 송금 버튼을 누르는 순간, 서버 응답 대기 없이 바로 '완료' 화면을 보여줍니다. 만약 실패하면 조용히 롤백하고 에러를 알립니다.
    *   **적용:** '좋아요', '즐겨찾기', '간단한 설정 변경' 등 실패 확률이 낮은 액션에 우선 적용하면 반응 속도가 0초로 느껴집니다.
*   **스켈레톤 UI (Skeleton UI):**
    *   **핵심:** 뱅글뱅글 도는 로딩 스피너 대신, 콘텐츠의 뼈대(회색 박스)를 먼저 보여줍니다.
    *   **효과:** 뇌가 "이미 로딩이 진행 중이다"라고 인식하게 하여 체감 대기 시간을 줄이고, 로딩 후 화면이 덜컹거리는 현상(Layout Shift)을 막습니다.
    *   **적용:** 데이터 로딩 중 상태(Loading State)에 스피너 대신 텍스트/이미지 크기와 유사한 회색 박스 컴포넌트를 배치하세요.

### 3. 데이터 관리 및 캐싱: "미리 가져오고, 재사용하기"

*   **SWR / React Query (TanStack Query) 활용:**
    *   **핵심:** 한 번 가져온 데이터는 캐시(Cache)에 저장해 두고, 재방문 시 네트워크 요청 없이 캐시 된 내용을 **즉시** 보여줍니다. 최신 데이터 갱신은 백그라운드에서 조용히 이루어집니다(Stale-While-Revalidate 전략).
    *   **적용:** API 호출 시 `axios`나 `fetch`를 직접 쓰는 대신, 데이터 캐싱 라이브러리를 도입하세요. 뒤로 가기 후 다시 돌아왔을 때 로딩이 아예 없는 경험을 줄 수 있습니다.
*   **Prefetching (프리페칭):**
    *   **핵심:** 사용자가 다음에 클릭할 확률이 높은 페이지의 리소스를 미리 당겨옵니다.
    *   **적용:** 사용자의 마우스가 버튼에 올라갔을 때(`hover`)나 해당 버튼이 화면에 보였을 때, 다음 페이지 데이터를 미리 요청해두면 클릭 시 즉시 화면이 전환됩니다.

### 4. 아키텍처 최적화: "효율적인 통신"

*   **BFF (Backend For Frontend) 패턴:**
    *   **문제:** 프론트엔드가 화면 하나를 그리기 위해 여러 API(유저 정보, 잔액, 공지사항 등)를 각각 호출하면 느려집니다.
    *   **해결:** 중간에 프론트엔드 전용 서버(BFF)를 두어, 필요한 데이터를 한 번에 묶어서(Aggregation) 받아옵니다. 모바일 환경에서 네트워크 왕복 횟수를 줄이는 것이 속도 향상의 지름길입니다.

### 5. 하이브리드 앱(WebView) 특화 기술

토스 앱 내부에서 웹페이지를 띄울 때 사용하는 기술입니다. 앱 내 웹뷰를 구현할 때 참고하세요.

*   **WebView Pre-warming (프리워밍):**
    *   사용자가 진입할 가능성이 높은 웹뷰 페이지는, 버튼을 누르기 전에 미리 보이지 않는 곳에서 로딩(초기화)을 끝내놓습니다. 클릭하는 순간 이미 로딩된 화면을 보여주기만 하면 됩니다.
*   **앱-웹 통신(Bridge) 최소화:**
    *   앱(Native)과 웹(JavaScript) 간의 통신은 비용이 큽니다. 불필요한 통신을 줄이고, 데이터를 한 번에 묶어서 보내는 방식으로 최적화합니다.

---

### 🚀 요약: 내 프로젝트에 바로 적용할 Action Item

토스급의 사용자 경험을 만들기 위해 다음 순서로 적용해 보세요.

1.  **기반 기술:** **Next.js**를 사용하여 초기 로딩 속도(SSR)를 확보하세요.
2.  **데이터:** **React Query (TanStack Query)**를 도입하여 캐싱과 백그라운드 업데이트를 구현하세요.
3.  **UI 패턴:**
    *   데이터 로딩 중에는 반드시 **스켈레톤 UI**를 보여주세요.
    *   클릭 이벤트(좋아요, 찜하기 등)에는 **낙관적 UI**를 적용해 딜레이를 없애세요.
4.  **이미지:** 이미지는 차세대 포맷(**WebP**)을 사용하고, **CDN**을 통해 전송하세요.
5.  **예측:** 사용자가 클릭할 것 같은 버튼에 마우스를 올리면 데이터를 미리 부르는 **Prefetching**을 적용하세요.

---

## 📘 스켈레톤 UI 상세 설명

### 스켈레톤 UI란?

실제 콘텐츠가 로딩되는 동안 **콘텐츠의 구조를 미리 보여주는** UI 패턴입니다.

#### 시각적 비교

**현재 (로딩 스피너)**:
```
┌─────────────────┐
│                 │
│    ⟳ 로딩 중...  │
│                 │
└─────────────────┘
```

**스켈레톤 UI**:
```
┌───────────────────┐
│ ▭▭▭  ▭▭▭▭▭     │  ← 흐릿한 박스가 반짝임
│ ▭▭   ▭▭▭▭▭     │
│ ▭▭▭  ▭▭▭▭▭     │
└───────────────────┘
```

---

### 🎨 구현 방법

#### 1. CSS (style.css)

```css
/* 스켈레톤 카드 */
.skeleton-card {
  background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
  background-size: 200% 100%;
  animation: shimmer 1.5s infinite;
  border-radius: 8px;
  height: 150px;
  margin-bottom: 16px;
}

@keyframes shimmer {
  0% { background-position: 200% 0; }
  100% { background-position: -200% 0; }
}

.skeleton-avatar {
  width: 60px;
  height: 60px;
  border-radius: 50%;
  background: #e0e0e0;
}

.skeleton-text {
  height: 16px;
  background: #e0e0e0;
  border-radius: 4px;
  margin-bottom: 8px;
}
```

#### 2. JavaScript 함수

```javascript
function showSkeletonLoading() {
  const resultsDiv = document.getElementById('results');
  
  let skeletonHTML = '';
  for (let i = 0; i < 10; i++) {
    skeletonHTML += `
      <div class="col-md-6 skeleton-card">
        <div class="d-flex align-items-center p-3">
          <div class="skeleton-avatar me-3"></div>
          <div class="flex-grow-1">
            <div class="skeleton-text" style="width: 60%;"></div>
            <div class="skeleton-text" style="width: 40%;"></div>
            <div class="skeleton-text" style="width: 80%;"></div>
          </div>
        </div>
      </div>
    `;
  }
  
  resultsDiv.innerHTML = `<div class="row">${skeletonHTML}</div>`;
}
```

#### 3. 적용 (script.js)

```javascript
async function loadData(isInit = true) {
    // 스켈레톤 표시
    showSkeletonLoading();  // 기존: showLoading(true)
    
    // 데이터 로드
    const quickUrl = `${API_URL}?...&limit=10`;
    const quickResponse = await fetch(quickUrl);
    
    // 실제 데이터 렌더링 (스켈레톤 자동 교체)
    renderList(currentMonth);
}
```

---

### ⚖️ 장단점

#### ✅ 장점

1. **체감 속도 향상** ⭐⭐⭐⭐⭐
   - 스피너: "로딩 중..." (지루함)
   - 스켈레톤: "곧 나올 것 같은데?" (기대감)

2. **UX 전문성**
   - YouTube, Facebook, LinkedIn 등 대형 서비스 사용
   - 사용자에게 "프리미엄" 느낌

3. **Layout Shift 방지**
   - 로딩 완료 후 화면이 덜컹거리지 않음
   - 콘텐츠 위치 예측 가능

4. **정보 제공**
   - "10개 카드가 나올 예정"임을 미리 알림
   - 무엇을 기다리는지 명확

#### ❌ 단점

1. **개발 복잡도 증가**
   - CSS 애니메이션: ~50줄
   - HTML 템플릿: ~30줄
   - JS 로직 수정: ~20줄

2. **실제 속도는 동일**
   - 현재: 1-2초 (이미 충분히 빠름)
   - 스켈레톤: 1-2초 (체감만 빠름)

3. **유지보수 포인트 추가**
   - 실제 카드 디자인 변경 시 스켈레톤도 수정 필요

4. **모바일 성능**
   - 애니메이션이 저사양 기기에서 버벅일 수 있음

---

### 🎯 적용 가이드

#### Toss 기준

```
1초 이내: 스켈레톤 불필요
1-3초: 스켈레톤 권장
3초 이상: 스켈레톤 필수
```

#### 현재 프로젝트 평가

**로딩 속도**: 1-2초 (10개 우선 로딩)

**결론**: 현재는 불필요

**이유**:
- 이미 충분히 빠름 (1-2초)
- 10개 우선 로딩으로 체감 속도 좋음
- 개발 투자 대비 효과 낮음

#### 구현 가치가 있는 경우

다음 상황이라면 고려하세요:

1. **프리미엄 브랜딩** 중요 시
2. **경쟁사 대비 차별화** 필요 시
3. **3G/4G 환경** 사용자 많을 시
4. **로딩 시간 3초 이상** 시

**현재는 구현하지 않는 것을 권장합니다. 이미 충분히 빠른 속도를 제공하고 있습니다!** 🚀